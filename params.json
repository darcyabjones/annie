{"name":"annie","tagline":"ANNotation Information Extractor","body":"This page is under development. Thank you for your patience!\r\n# Introduction\r\n### License\r\nannie is released under the [MIT License](http://opensource.org/licenses/MIT)\r\n### Purpose\r\nThe purpose of annie is relatively simple. annie takes your input files (blastout, fasta, gff, etc), does the appropriate cross-referencing for you, and spits out a file that contains the appropriate annotations written in a 3-column table format.\r\n### Installation\r\nannie is written in the beautiful language of [Python 2](https://www.python.org/download/releases/2.7.6/) . If you have Python 2 (not 3!) installed on your computer, you can download the zipped source code link at the top of the page and extract it. That's it!\r\n### Citing annie\r\nIf you'd like to flatter us, please cite us as follows:\r\n> Tate, R., Hall, B., DeRego, T., & Geib, S. (2014). annie: the ANNotation Information Extractor (Version 1.0) [Software]. Available from [http://genomeannotation.github.io/Annie](http://genomeannotation.github.io/Annie).\r\n\r\n# Usage\r\n### Getting Started\r\nFirst, open up your command prompt/terminal traverse your directories until your reach the annie directory (wherever you decided to extract it on your computer). Once there, you will want to run a command in the following form:\r\n\r\n`python annie.py <case> <input_file1> [<input_file2> ...] <output_file>`\r\n\r\nCurrently, Annie works with two cases: ipr and sprot. More information about the inputFile and outputFile fields are outlined below.\r\n\r\nIf you ever get lost and want to know what the valid inputs for annie are just type:\r\n`python annie.py help`\r\nand help will be on the way shortly.\r\n\r\n### ipr\r\nFor ipr, the command has the following form:\r\n\r\n`python annie.py ipr <ipr_input_file> <output_file>`\r\n\r\nSo an example of what an actual command might look like would be:\r\n\r\n`python annie.py ipr my_ipr_file.ipr my_super_secret_output_file.txt`\r\n\r\nThe output file name can be whatever you want it to be, that's your chance to be creative! Another thing to note is that the file extensions don't matter for either the input and output files. For example, your ipr file could have an extension `.animu` and everything would work just fine.\r\n\r\nThe output file is a table of annotations. For each row in the ipr file, it contains the mrna id and the dbxref. It also contains the GO and IPR values if they exist. For each row, we create up to 3 annotations where the feature id is the mrna id, and the keys are \"dbxref\", \"IPR\" and \"GO\" with their respective values. Here is a sample input/output pair:\r\n\r\nInput:\r\n\r\n`m.98281\tc95b0824ccd627403aa63f9e474649cc\t7571\tPfam\tPF00041\tFibronectin type III domain\t3729\t3812\t4.7E-14\tT\t04-04-2014\tIPR003961\tFibronectin, type III\tGO:0005515`\t\r\n\r\n`m.98281\tc95b0824ccd627403aa63f9e474649cc\t7571\tPfam\tPF00041\tFibronectin type III domain\t6484\t6567\t1.8E-12\tT\t04-04-2014\tIPR003961\tFibronectin, type III\tGO:0005515\t`\r\n\r\n`m.42655\tde17ff06d901d22dacc3f5c91510f33f\t288\tPfam\tPF12171\tZinc-finger double-stranded RNA-binding\t45\t69\t1.3E-5\tT\t05-04-2014\tIPR022755\tZinc finger, double-stranded RNA binding\t`\t\r\n\r\n`m.82734\tae22a6fcc80b2ac982378f16ac022b3d\t144\tPfam\tPF14846\tDomain of unknown function (DUF4485)\t8\t89\t4.8E-17\tT\t05-04-2014\tIPR027831\tDomain of unknown function DUF4485\t\t`\r\n\r\nOutput:\r\n\r\n`m.42655\tDbxref\tPFAM:PF12171`\r\n\r\n`m.42655\tInterPro\tIPR022755`\r\n\r\n`m.82734\tDbxref\tPFAM:PF14846`\r\n\r\n`m.82734\tInterPro\tIPR027831`\r\n\r\n`m.98281\tDbxref\tPFAM:PF00041`\r\n\r\n`m.98281\tGO\tGO:0005515`\r\n\r\n`m.98281\tInterPro\tIPR003961`\r\n\r\nA few notes on the sample input/output:\r\n* The GO annotation doesn't appear for every mrna because not every mrna has one.\r\n* Notice that the mrna, dbxref, GO, and IPR values for the first two entries in the input are the same so they result in the same annotations. Knowing that nobody has time for duplicate annotations, annie automatically removes them for you.\r\n* The output has the annotations _ordered_. In other words, it first sorts by the feature id (the mrna id), then by the key (e.g. \"Dbxref\", \"GO\", \"InterPro\"), then by the value.\r\n\r\nAnnie makes a few assumptions about your input files so if something doesn't work, check to see if your file meets these assumptions:\r\n* values in each row are tab-separated\r\n* the first column is the mrna id\r\n* the 4th and 5th columns correspond to your dbxref\r\n* the 12th column is the IPR column if the 12th column exists\r\n* the 14th column is the GO column if the 14th column exists\r\n\r\n### sprot\r\nFor sprot, the command has the following form, it's a bit longer compared to ipr:\r\n\r\n`python annie.py sprot <blastout_file_name> <gff_file_name> <fasta_file_name> <output_file_name> `\r\n\r\nSo essentially, we take three input files (blast, gff, and fasta). So an example of what an actual command might look like would be:\r\n\r\n`python annie.py sprot my_blast_file.blast my_gff_file.gff my_fasta_file.fasta my_results.txt`\r\n\r\nOnce again, the output file can be named anything you want. Another thing to note is that the file extensions don't matter for either the input and output files. For example, your gff file could have an extension `.velociraptor` and everything would work just fine.\r\n\r\nThe output file is a table of annotations just like the ipr case. The sprot case is a bit more complicated so we'll go through the details before moving on to the sample input/output. First of all, the main goal is to write annotations for all the mrna's in the blastout file. Secondly, for each of those mrna's, we want to write annotations for their corresponding parent gene. \r\n\r\nThe sprot case returns two types of annotations. The first is a product annotation in the form `<mrna_id> product <product>`. We use the blast file to get the dbxref for the associated mrna and then we use the fasta file to take that dbxref and get the corresponding product. Here is a diagram of what goes on:\r\n\r\n`mrna_id ---blast_file---> dbxref ---fasta_file---> product`\r\n\r\nNext, we have the name annotation. The name annotation has the form `<parent_gene_id> name <parent_gene_name>`. First, for each mrna in the blast results, we look it up in the gff file to get the corresponding parent gene id. That is how we obtain the `<parent_gene_id>` portion of the annotation. The process to obtain the `<parent_gene_name>` is similar to getting the product for the product annotation. First, we use the blast file to get the associated dbxref from the mrna and then we use the fasta file to take that dbxref ref and give us the gene name. Here is a diagram of how the name annotation is made:\r\n\r\n`mrna_id ---gff_file---> parent_gene_id`\r\n\r\n`mrna_id ---blast_file---> dbxref ---fasta_file---> parent_gene_name`\r\n\r\nNow that we understand what this case is doing, let's take a look at some sample input/output:\r\n\r\n##### Input\r\n\r\n###### blast file\r\n\r\n`m.4830\tsp|Q5AZY1|MRH4_EMENI\t32.65\t49\t33\t0\t114\t162\t500\t548\t0.56\t34.3`\r\n\r\n`m.4831\tsp|Q9TTC1|POL_KORV\t32.26\t155\t102\t3\t23\t174\t807\t961\t1e-16\t81.6`\r\n\r\n`m.4837\tsp|P05892|GAG_SIVVT\t45.24\t42\t21\t2\t35\t75\t394\t434\t0.012\t38.1`\r\n\r\n`m.4838\tsp|Q9UGP4|LIMD1_HUMAN\t29.58\t71\t42\t3\t32\t96\t369\t437\t0.88\t31.6`\r\n\r\n###### gff file\r\n\r\n`comp9975_c0_seq1\t.\tgene\t25\t603\t.\t+\t.\tID=g.4830;Name=ORF%20g.4830%20m.4830%20type%3Acomplete%20len%3A193%20%28%2B%29`\r\n\r\n`comp9975_c0_seq1\t.\tmRNA\t25\t603\t.\t+\t.\tID=m.4830;Parent=g.4830`\r\n\r\n`comp9975_c0_seq1\t.\tCDS\t25\t603\t.\t+\t.\tID=cds.m.4830;Parent=m.4830`\r\n\r\n`comp9975_c1_seq1\t.\tgene\t3\t533\t.\t+\t.\tID=g.4831;Name=ORF%20g.4831%20m.4831%20type%3Ainternal%20len%3A176%20%28%2B%29`\r\n\r\n`comp9975_c1_seq1\t.\tmRNA\t3\t533\t.\t+\t.\tID=m.4831;Parent=g.4831`\r\n\r\n`comp9975_c1_seq1\t.\tCDS\t3\t533\t.\t+\t.\tID=cds.m.4831;Parent=m.4831`\r\n\r\n`comp9982_c0_seq1\t.\tgene\t1\t441\t.\t-\t.\tID=g.4837;Name=ORF%20g.4837%20m.4837%20type%3Ainternal%20len%3A147%20%28-%29`\r\n\r\n`comp9982_c0_seq1\t.\tmRNA\t1\t441\t.\t-\t.\tID=m.4837;Parent=g.4837`\r\n\r\n`comp9982_c0_seq1\t.\tCDS\t1\t441\t.\t-\t.\tID=cds.m.4837;Parent=m.4837`\r\n\r\n`comp9983_c0_seq1\t.\tgene\t1746\t2060\t.\t+\t.\tID=g.4838;Name=ORF%20g.4838%20m.4838%20type%3A3prime_partial%20len%3A104%20%28%2B%29`\r\n\r\n`comp9983_c0_seq1\t.\tmRNA\t1746\t2060\t.\t+\t.\tID=m.4838;Parent=g.4838`\r\n\r\n`comp9983_c0_seq1\t.\tCDS\t1746\t2060\t.\t+\t.\tID=cds.m.4838;Parent=m.4838`\r\n\r\n###### fasta file \r\n(we removed the sequences for readability of this example)\r\n\r\n`>sp|Q5AZY1|MRH4_EMENI ATP-dependent RNA helicase mrh4, mitochondrial OS=Emericella nidulans (strain FGSC A4 / ATCC 38163 / CBS 112.46 / NRRL 194 / M139) GN=mrh4 PE=3 SV=1`\r\n\r\n`>sp|Q9TTC1|POL_KORV Pro-Pol polyprotein OS=Koala retrovirus GN=pro-pol PE=3 SV=1`\r\n\r\n`>sp|P05892|GAG_SIVVT Gag polyprotein OS=Simian immunodeficiency virus agm.vervet (isolate AGM TYO-1) GN=gag PE=3 SV=1`\r\n\r\n`>sp|Q9UGP4|LIMD1_HUMAN LIM domain-containing protein 1 OS=Homo sapiens PE=1 SV=1`\r\n\r\n##### Output\r\n\r\n`g.4838\tname\tLIMD1`\r\n\r\n`m.4838\tproduct\tLIM domain-containing protein 1`\r\n\r\n`g.4830\tname\tmrh4`\r\n\r\n`m.4830\tproduct\tATP-dependent RNA helicase mrh4, mitochondrial`\r\n\r\n`g.4831\tname\tpro-pol`\r\n\r\n`m.4831\tproduct\tPro-Pol polyprotein`\r\n\r\n`g.4837\tname\tgag`\r\n\r\n`m.4837\tproduct\tGag polyprotein`\r\n\r\n\r\nA few notes on the sample input/output:\r\n* Not every gene id has an associated gene name. In that case, we use part of the dbxref to name it (the part after the second '|' and from that part, the part before the first '_').\r\n* Although not seen here, if two name annotations have the same value (i.e. the same parent gene name), we index them by adding a \"_0\" in front of the first one, a \"_1\" in front of the second one, etc.\r\n* Although not seen here, if annie fails to cross-reference something, it'll skip doing that annotation and gently notify you in the command prompt/terminal.\r\n\r\nAnnie makes a few assumptions about your input files so if something doesn't work, check to see if your file meets these assumptions:\r\n* in the blast file, every row has tab-separated values with the mrna id in the first row and the dbxref in the second row\r\n* in the gff file, every row has tab separated values\r\n* in the gff file, the third column has the feature type (\"mRNA\", etc). We also assume the third column, if it is for mrna, has exactly the value \"mRNA\" with no surrounding whitespace or changes in captilization.\r\n* in the gff file, the 9th column should have the mrna id and parent gene id in exactly the following form: `ID=<mrna_id>;Parent=<parent_gene_id>` so an example would ne `ID=m.123;Parent=g.123`\r\n* in the fasta file, if the line is a header line, the first character is '>'\r\n* in the fasta file, the dbxref is immediately the first thing to appear after the '>' with no whitespace inbetween the '>' and the dbxref\r\n* in the fasta file, the dbxref has no whitespace contained inside\r\n* in the fasta file, the product is everything between the dbxref and the string \"OS=\" which we assume exists\r\n* in the fasta file, if the gene name exists, it contains no whitespace within\r\n* in the fasta file, if the gene name exists, it is right before the string \"PE=\" which we assume exists\r\n* in the fasta file, we assume the gene name is in the following form: `GN=<gene_name>`. An example would be `GN=gag`\r\n\r\n# Configuration\r\nCurrently, annie only has one type of configuration: the whitelist. More information below.\r\n### Dbxref Whitelist\r\nThe whitelist is used for the ipr case. If the database type (e.g. 'Pfam') is not in the whitelist, then the annotation won't be written. In other words, annotations are only written for _valid_ databases contained in the whitelist file. annie will convert both the whitelist entry and the ipr file entry to lowercase and trim surrounding whitespace before comparing them against each other, i.e., annie doesn't care about case-sensitivity or whitespace when it comes to the databases names in the ipr file and the whitelist.\r\n\r\nTo edit the whitelist, go to the Annie directory, then go to the config subdirectory. As of the latest version of annie, there should only be the whitelist file in there. Feel free to delete entries as desired or to add new entries on a new line. Or delete _all_ the entries! Up to you; go wild my friend.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}